#include "chacha_prng.h"
#include "common.h"
#include "procs_utils.h"

#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

// batched_entropy. defined one per cpu
struct batched_entropy {
        union {
                unsigned long entropy_long[CHACHA20_BLOCK_SIZE / sizeof(unsigned long)];
                unsigned int entropy_int[CHACHA20_BLOCK_SIZE / sizeof(unsigned int)];
        };
        unsigned int position;
};

struct batched_entropy batched_entropy_long;

void analyze_extractions(struct extractions ex, ull previous_read_time, ull current_read_time) {
	// for now, just classify extractions based on known types. 
	// ex. a 64, non-backtracked extraction is likely a reseeding of batched_entropy
	int i;
	for (i = 0; i < ex.num_extractions; ++i) {
		if (ex.extractions[i].et.size == 64 && !ex.extractions[i].et.backtrack) {
			printf("Found extraction that is likely to be reseed of batched_entropy\n");
            memcpy(&batched_entropy_long.entropy_long, ex.extractions[i].data, 64);
            batched_entropy_long.position = 0;
		}
	}

	// also find out when extractions happened and infer which process is running
    // go through running processes in /proc and get start time in /proc/<pid>/stat
    int *pids;
    int npids;
    if ((npids = get_currently_running_pids(&pids)) < 0) {
        fprintf(stderr, "couldn't get currently running processes\n");
        return;
    }

    printf("Found %d processes running\n", npids);
    for (i = 0; i < npids; ++i) {
        int stat_fd;
        char stat_path[256];
        char read_buf[1024];

        if (snprintf(stat_path, sizeof(stat_path), "/proc/%d/stat", pids[i]) < 0)
            continue;

        if ((stat_fd = open(stat_path, O_RDONLY)) < 0)
            continue;
        
        if (read(stat_fd, read_buf, sizeof(read_buf)) < 0)
            goto pid_done;

        // get process start time from read_buf
        int j = 0;
        char *start_time_ptr = read_buf;
        while (j++ < 21) {
            if ((start_time_ptr = strchr(start_time_ptr, ' ')) == NULL)
                goto pid_done;
            start_time_ptr += strspn(start_time_ptr, " ");
        }

        ul process_start_jiffies = strtol(start_time_ptr, NULL, 10);
        struct timeval tv;
        jiffies_to_timeval(process_start_jiffies, &tv);
        ull start_us = (1492583439 * 1e6);
        ull process_start_time = timeval_to_us(&tv);

        if ((previous_read_time - start_us) <= process_start_time && process_start_time <= (current_read_time - start_us)) {
            // process was started in between reads
            start_time_ptr = strchr(read_buf, ' ');
            start_time_ptr += strspn(start_time_ptr, " ");
            
            printf("[%d][%.*s] started at %llu jiffies [%llu us], [prev: %llu us, curr: %llu us]\n", 
                pids[i], (int) (strchr(start_time_ptr, ' ') - start_time_ptr), start_time_ptr, 
                process_start_jiffies, timeval_to_us(&tv), previous_read_time - start_us, current_read_time - start_us);
        }
pid_done:
        close(stat_fd);
    }

    free(pids);
}